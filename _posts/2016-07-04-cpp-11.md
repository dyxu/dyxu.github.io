---
layout: post
title: C++11新特性
author: dyxu
keywords: ["C++11"]
description:
categories:
  - 技术
tags: ["C++"]
---

{% include JB/setup %}

> C++11是曾经被叫做C++0x，是对目前C++语言的扩展和修正，C++11不仅包含核心语言的新机能，而且扩
> 展了C++的标准程序库（STL），并入了大部分的C++ Technical Report 1（TR1）程序库(数学的特殊
> 函数除外)。
>
> C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进。
> 编译器通过添加 `-std=c++11` 或者 `-std=c++0x` 参数来支持C++11。

## 核心语言运行时性能强化

以下特性基本上用于提升程序运行时的性能。

### 右值引用和move语义

右值引用(R-values)是C++11标准中一个令人难以捉摸的特性。在Ｃ语言时代，左值和右值的定义如下：
**左值是一个可以出现在赋值运算符左边或者右边的表达式exp，而右值是只能出现在右边的表达式。**，
例如：

    int a = 1;  
    int b = 2;
    // a和b是左值
    a = b;  // ok
    b = a;  // ok

    // a * b是右值
    a * b = 11;   // error

在C++中由于自定义类型的引入使得上述的定义变得不那么准确，另一个较好的定义**左值是一个指向某内存
空间的表达式，并且我们可以用&操作符获得该内存空间的地址，右值就是非左值的表达式。**

    int a = 1;  // ok
    int *ptr = &a; // ok
    int& func();
    func() = 42;  // ok
    // ptr, a和func()都是左值

    int rfunc();
    int *ptr1 = &rfunc(); // error rfunc()是右值
    int *ptr = &42; // error 42是右值

右值引用的加入主要是为了解决move语义和完美转发。

(未完待续)

### 常量表达式constexpr

C++11中引入了新的关键字constexpr，其语义是“常量表达式”，即在编译期间可以求值的表达式。如：

    constexpr int func(int t) {
        return t + 1;
    }

    constexpr int a = func(1);  // ok
    constexpr int b = func(cin.get()); // error
    constexpr int c = a * 2 + 3; // ok

constexpr还可以用于修饰类的构造函数，在保证如果提供给构造函数的参数都是constexpr的前提下，那
么产生的对象中的所有成员都会是constexpr，可用于各种只能使用constexpr对象的场合。

## 核心语言编译期间的加强

### 外部模板

在标准C++中，在编译过程中需要对出现的每一处模板进行实例化；链接时，链接器还要移除重复的实例化代
码，有时候这会大大增加编译和链接的时间。而在C++中已经有强制编译器在特定位置进行实例化的语法了：

    template class std::vector<MyClass>;

 在C++11中简单地加入了外部模板的语法：

    extern template class std::vector<MyClass>;

例如：

    // func.h
    template <typename T>
    void func(T t) { }

    // src1.cpp
    void test0() {
        func<int>(1);
    }

    // src2.cpp
    extern template void func<int>(int);
    void test1() {
        func<int>(1);
    }   

## 核心语言使用性的加强

### 统一初始化语法

C++11用大括号统一了初始化的方法。

对于POD类型([Plain Old Data](https://zh.wikipedia.org/wiki/POD_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)):

    int arr[3] = {1, 2, 3};
    struct tm today = {0};

在类(class/struct)是极简的、属于标准布局，以及它的所有非静态变量成员都是POD时，会被识别为POD。

    struct A { int m; }; // POD
    struct B { ~B(); int m; }; // non-POD
    struct C { C() : m() {}; ~(); int m; }; // non-POD

对于POD类型如上述中类A, `new A`和`new A()`是不一样的，前者m没有被初始化话，后者被初始化了。
而对于non-POD类型，两种方式m都会被初始化。因此，在C++11中对初始化进行了统一。

    int * nums = new int[3]{1, 2, 3}; // C++11 only
    class X {
      private:
        int nums_[4];
      public:
            X() : nums_{1, 2, 3, 4} {} // C++11 only
    };

    vector<string> vs = {"first", "second", "third"};
    map<string, string> user = {
        {"Lady Gaga", "123456789"},
        {"Michael Joseph", "987654321"}};

### 类型推导

在标准C++和C中，使用变量定义时必须指明其类型。但是在模板编程中有时候函数的返回值难以确定，为了
解决上述的问题，C++11引入了两个新的关键字: auto和decltype。 auto的示例如下：

```cpp
auto a = 0;   // int
auto b = 'b'; // char
vecotr<string> vs;
auto it = vs.begin(); // vector<string>::const_iterator 
```

decltype用于评估括号内的类型，对于decltype(expr)其规则如下：

1. 如果表达式expr是一个变量，那么代表该变量的类型。
2. 如果表达式expr是一个函数，那么代表函数返回值的类型。
3. 如果不符合1和2，如果expr是左值，类型为T，那么decltype(e)是T&；如果是右值，则是T。

示例如下：

```cpp
template <typename X, typename Y>
auto z = [](X x, Y y)->decltype(x+y) { return x + y;}
```

### 基于范围的for循环

直接上示例：

```cpp
int arr[3] = {1, 2, 3};
for(const int& e : arr) {
    std::cout << e << std::endl;
}

for(auto& e : arr) { // or auto& e => int& e
    e &= 0xFF;
}
```

### Lambda 表达式

C++11中引入了Lambda表达式，既匿名函数。其语法如下

```cpp
[capture](parameters) -> return_type { body }
[]  // body中不能引用外部变量
[=] // body中外部变量以值传递的形式传入
[&] // body中外部变量以引用的形式传入
[x, &y]  // body中x值传递的形式传入，y为引用传入
[&, x] // body中除了x为值传递外其他都是引用传递
[=, x]
[=, &x] 
->return_type // 为可选项
```
示例：

```cpp
int sum = 0;
vector<int> v{1, 2, 3};
for_each(v.begin(), v.end(), [&sum](int x) {
    sum += x;
});
```